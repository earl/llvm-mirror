; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs -O3 < %s | FileCheck %s
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.11.0"

declare void @bar() #0
declare void @baz()

define void @test1(i32 %a) gc "statepoint-example" {
; CHECK-LABEL: test1:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    callq _bar
; CHECK-NEXT:  Ltmp0:
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
entry:
; We expect the argument to be passed in an extra register to bar
  %statepoint_token1 = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 1, i32 %a)
  ret void
}

define void @test2(i32 %a, i32 %b) gc "statepoint-example" {
; CHECK-LABEL: test2:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset %rbx, -24
; CHECK-NEXT:    .cfi_offset %rbp, -16
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    callq _bar
; CHECK-NEXT:  Ltmp1:
; CHECK-NEXT:    callq _bar
; CHECK-NEXT:  Ltmp2:
; CHECK-NEXT:    addq $8, %rsp
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:    retq
entry:
; Because the first call clobbers esi, we have to move the values into
; new registers.  Note that they stay in the registers for both calls.
  call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 2, i32 %a, i32 %b)
  call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 2, i32 %b, i32 %a)
  ret void
}

define void @test3(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i) gc "statepoint-example" {
; CHECK-LABEL: test3:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    callq _bar
; CHECK-NEXT:  Ltmp3:
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
entry:
; We directly reference the argument slot
  %statepoint_token1 = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 9, i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i)
  ret void
}

; This case just confirms that we don't crash when given more live values
; than registers.  This is a case where we *have* to use a stack slot.  This
; also ends up being a good test of whether we can fold loads from immutable
; stack slots into the statepoint.
define void @test4(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z) gc "statepoint-example" {
; CHECK-LABEL: test4:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    callq _bar
; CHECK-NEXT:  Ltmp4:
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
entry:
  %statepoint_token1 = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 26, i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z)
  ret void
}

; A live-through gc-value must be spilled even if it is also a live-in deopt
; value.  For live-in, we could technically report the register copy, but from
; a code quality perspective it's better to reuse the required stack slot so
; as to put less stress on the register allocator for no benefit.
define  i32 addrspace(1)* @test5(i32 %a, i32 addrspace(1)* %p) gc "statepoint-example" {
; CHECK-LABEL: test5:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    movq %rsi, (%rsp)
; CHECK-NEXT:    callq _bar
; CHECK-NEXT:  Ltmp5:
; CHECK-NEXT:    movq (%rsp), %rax
; CHECK-NEXT:    popq %rcx
; CHECK-NEXT:    retq
entry:
  %token = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 1, i32 %a, i32 addrspace(1)* %p, i32 addrspace(1)* %p)
  %p2 = call i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %token,  i32 9, i32 9)
  ret i32 addrspace(1)* %p2
}

; Show the interaction of live-through spilling followed by live-in.
define void @test6(i32 %a) gc "statepoint-example" {
; CHECK-LABEL: test6:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    subq $16, %rsp
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset %rbx, -16
; CHECK-NEXT:    movl %edi, %ebx
; CHECK-NEXT:    movl %edi, {{[0-9]+}}(%rsp)
; CHECK-NEXT:    callq _baz
; CHECK-NEXT:  Ltmp6:
; CHECK-NEXT:    callq _bar
; CHECK-NEXT:  Ltmp7:
; CHECK-NEXT:    addq $16, %rsp
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    retq
entry:
  call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @baz, i32 0, i32 0, i32 0, i32 1, i32 %a)
  call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 1, i32 %a)
  ret void
}

; A variant of test7 where values are not directly foldable from stack slots.
define void @test7(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z) gc "statepoint-example" {
; The code for this is terrible, check simply for correctness for the moment
; CHECK-LABEL: test7:
; CHECK:    callq _bar
entry:
  %a64 = zext i32 %a to i64
  %b64 = zext i32 %b to i64
  %c64 = zext i32 %c to i64
  %d64 = zext i32 %d to i64
  %e64 = zext i32 %e to i64
  %f64 = zext i32 %f to i64
  %g64 = zext i32 %g to i64
  %h64 = zext i32 %h to i64
  %i64 = zext i32 %i to i64
  %j64 = zext i32 %j to i64
  %k64 = zext i32 %k to i64
  %l64 = zext i32 %l to i64
  %m64 = zext i32 %m to i64
  %n64 = zext i32 %n to i64
  %o64 = zext i32 %o to i64
  %p64 = zext i32 %p to i64
  %q64 = zext i32 %q to i64
  %r64 = zext i32 %r to i64
  %s64 = zext i32 %s to i64
  %t64 = zext i32 %t to i64
  %u64 = zext i32 %u to i64
  %v64 = zext i32 %v to i64
  %w64 = zext i32 %w to i64
  %x64 = zext i32 %x to i64
  %y64 = zext i32 %y to i64
  %z64 = zext i32 %z to i64
  %statepoint_token1 = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 26, i64 %a64, i64 %b64, i64 %c64, i64 %d64, i64 %e64, i64 %f64, i64 %g64, i64 %h64, i64 %i64, i64 %j64, i64 %k64, i64 %l64, i64 %m64, i64 %n64, i64 %o64, i64 %p64, i64 %q64, i64 %r64, i64 %s64, i64 %t64, i64 %u64, i64 %v64, i64 %w64, i64 %x64, i64 %y64, i64 %z64)
  ret void
}

; a variant of test7 with mixed types chosen to exercise register aliases
define void @test8(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z) gc "statepoint-example" {
; The code for this is terrible, check simply for correctness for the moment
; CHECK-LABEL: test8:
; CHECK:    callq _bar
entry:
  %a8 = trunc i32 %a to i8
  %b8 = trunc i32 %b to i8
  %c8 = trunc i32 %c to i8
  %d8 = trunc i32 %d to i8
  %e16 = trunc i32 %e to i16
  %f16 = trunc i32 %f to i16
  %g16 = trunc i32 %g to i16
  %h16 = trunc i32 %h to i16
  %i64 = zext i32 %i to i64
  %j64 = zext i32 %j to i64
  %k64 = zext i32 %k to i64
  %l64 = zext i32 %l to i64
  %m64 = zext i32 %m to i64
  %n64 = zext i32 %n to i64
  %o64 = zext i32 %o to i64
  %p64 = zext i32 %p to i64
  %q64 = zext i32 %q to i64
  %r64 = zext i32 %r to i64
  %s64 = zext i32 %s to i64
  %t64 = zext i32 %t to i64
  %u64 = zext i32 %u to i64
  %v64 = zext i32 %v to i64
  %w64 = zext i32 %w to i64
  %x64 = zext i32 %x to i64
  %y64 = zext i32 %y to i64
  %z64 = zext i32 %z to i64
  %statepoint_token1 = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 26, i8 %a8, i8 %b8, i8 %c8, i8 %d8, i16 %e16, i16 %f16, i16 %g16, i16 %h16, i64 %i64, i64 %j64, i64 %k64, i64 %l64, i64 %m64, i64 %n64, i64 %o64, i64 %p64, i64 %q64, i64 %r64, i64 %s64, i64 %t64, i64 %u64, i64 %v64, i64 %w64, i64 %x64, i64 %y64, i64 %z64)
  ret void
}

; Test perfect forwarding of argument registers and stack slots to the
; deopt bundle uses
define void @test9(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z) gc "statepoint-example" {
; CHECK-LABEL: test9:
; CHECK:      pushq %rax
; CHECK-NEXT: .cfi_def_cfa_offset 16
; CHECK-NEXT: callq _bar
; CHECK-NEXT: Ltmp10:
; CHECK-NEXT: popq %rax
; CHECK-NEXT: retq

entry:
  %statepoint_token1 = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 26, i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z)
  ret void
}

; Test enough folding of argument slots when we have one call which clobbers
; registers before a second which needs them - i.e. we must do something with
; arguments originally passed in registers
define void @test10(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z) gc "statepoint-example" {
; FIXME (minor): It would be better to just spill (and fold reload) for
; argument registers then spill and fill all the CSRs.
; CHECK-LABEL: test10:
; CHECK:      pushq	%rbp
; CHECK:      pushq	%r15
; CHECK:      pushq	%r14
; CHECK:      pushq	%r13
; CHECK:      pushq	%r12
; CHECK:      pushq	%rbx
; CHECK:      pushq	%rax
; CHECK:      movl	%r9d, %r15d
; CHECK-NEXT: movl	%r8d, %r14d
; CHECK-NEXT: movl	%ecx, %r12d
; CHECK-NEXT: movl	%edx, %r13d
; CHECK-NEXT: movl	%esi, %ebx
; CHECK-NEXT: movl	%edi, %ebp
; CHECK-NEXT: callq _bar
; CHECK-NEXT: Ltmp11:
; CHECK-NEXT: callq _bar
; CHECK-NEXT: Ltmp12:
; CHECK-NEXT: addq	$8, %rsp
; CHECK-NEXT: popq	%rbx
; CHECK-NEXT: popq	%r12
; CHECK-NEXT: popq	%r13
; CHECK-NEXT: popq	%r14
; CHECK-NEXT: popq	%r15
; CHECK-NEXT: popq	%rbp
; CHECK-NEXT: retq

entry:
  %statepoint_token1 = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 26, i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z)
  %statepoint_token2 = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 26, i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i32 %h, i32 %i, i32 %j, i32 %k, i32 %l, i32 %m, i32 %n, i32 %o, i32 %p, i32 %q, i32 %r, i32 %s, i32 %t, i32 %u, i32 %v, i32 %w, i32 %x, i32 %y, i32 %z)
  ret void
}

; CHECK: Ltmp0-_test1
; CHECK:      .byte	1
; CHECK-NEXT:   .byte   0
; CHECK-NEXT: .short 4
; CHECK-NEXT: .short	5
; CHECK-NEXT:   .short  0
; CHECK-NEXT: .long	0

; CHECK: Ltmp1-_test2
; CHECK:      .byte	1
; CHECK-NEXT:   .byte   0
; CHECK-NEXT: .short 4
; CHECK-NEXT: .short	6
; CHECK-NEXT:   .short  0
; CHECK-NEXT: .long	0
; CHECK:      .byte	1
; CHECK-NEXT:   .byte   0
; CHECK-NEXT: .short 4
; CHECK-NEXT: .short	3
; CHECK-NEXT:   .short  0
; CHECK-NEXT: .long	0
; CHECK: Ltmp2-_test2
; CHECK:      .byte	1
; CHECK-NEXT:   .byte   0
; CHECK-NEXT: .short 4
; CHECK-NEXT: .short	3
; CHECK-NEXT:   .short  0
; CHECK-NEXT: .long	0
; CHECK:      .byte	1
; CHECK-NEXT:   .byte   0
; CHECK-NEXT: .short 4
; CHECK-NEXT: .short	6
; CHECK-NEXT:   .short  0
; CHECK-NEXT: .long	0

declare token @llvm.experimental.gc.statepoint.p0f_isVoidf(i64, i32, void ()*, i32, i32, ...)
declare i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token, i32, i32)


attributes #0 = { "deopt-lowering"="live-in" }
attributes #1 = { "deopt-lowering"="live-through" }
