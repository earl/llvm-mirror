; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-unknown-unknown -show-mc-encoding < %s | FileCheck %s

; Test that the direct object emission selects the and variant with 8 bit
; immediate.
; We used to get this wrong when using direct object emission, but not when
; reading assembly.


target triple = "x86_64-pc-linux"

define void @f1() nounwind {
; CHECK-LABEL: f1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    pushq %rbp # encoding: [0x55]
; CHECK-NEXT:    movq %rsp, %rbp # encoding: [0x48,0x89,0xe5]
; CHECK-NEXT:    andq $-32, %rsp # encoding: [0x48,0x83,0xe4,0xe0]
; CHECK-NEXT:    movq %rbp, %rsp # encoding: [0x48,0x89,0xec]
; CHECK-NEXT:    popq %rbp # encoding: [0x5d]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %foo = alloca i8, align 32
  ret void
}

define void @f2(i16 %x, i1 *%y) nounwind  {
; CHECK-LABEL: f2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andl $1, %edi # encoding: [0x83,0xe7,0x01]
; CHECK-NEXT:    movb %dil, (%rsi) # encoding: [0x40,0x88,0x3e]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %c = trunc i16 %x to i1
  store i1 %c, i1* %y
  ret void
}

define void @f3(i32 %x, i1 *%y) nounwind {
; CHECK-LABEL: f3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andl $1, %edi # encoding: [0x83,0xe7,0x01]
; CHECK-NEXT:    movb %dil, (%rsi) # encoding: [0x40,0x88,0x3e]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %c = trunc i32 %x to i1
  store i1 %c, i1* %y
  ret void
}

