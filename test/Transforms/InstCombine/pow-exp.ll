; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -instcombine -S | FileCheck %s

; TODO: Should result in expf(x * y).
define float @powf_expf(float %x, float %y) {
; CHECK-LABEL: @powf_expf(
; CHECK-NEXT:    [[CALL:%.*]] = call fast float @expf(float [[X:%.*]]) #1
; CHECK-NEXT:    [[POW:%.*]] = call fast float @llvm.pow.f32(float [[CALL]], float [[Y:%.*]])
; CHECK-NEXT:    ret float [[POW]]
;
  %call = call fast float @expf(float %x) nounwind readnone
  %pow = call fast float @llvm.pow.f32(float %call, float %y)
  ret float %pow
}

; TODO: Should result in intrinsic call to exp().
define double @pow_exp(double %x, double %y) {
; CHECK-LABEL: @pow_exp(
; CHECK-NEXT:    [[MUL:%.*]] = fmul fast double [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[EXP:%.*]] = call fast double @exp(double [[MUL]])
; CHECK-NEXT:    ret double [[EXP]]
;
  %call = call fast double @exp(double %x) nounwind readnone
  %pow = call fast double @llvm.pow.f64(double %call, double %y)
  ret double %pow
}

; TODO: Should result in exp2f(x * y).
define float @powf_exp2f(float %x, float %y) {
; CHECK-LABEL: @powf_exp2f(
; CHECK-NEXT:    [[CALL:%.*]] = call fast float @exp2f(float [[X:%.*]]) #1
; CHECK-NEXT:    [[POW:%.*]] = call fast float @llvm.pow.f32(float [[CALL]], float [[Y:%.*]])
; CHECK-NEXT:    ret float [[POW]]
;
  %call = call fast float @exp2f(float %x) nounwind readnone
  %pow = call fast float @llvm.pow.f32(float %call, float %y)
  ret float %pow
}

; TODO: Should result in intrinsic call to exp2().
define double @pow_exp2(double %x, double %y) {
; CHECK-LABEL: @pow_exp2(
; CHECK-NEXT:    [[MUL:%.*]] = fmul fast double [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[EXP2:%.*]] = call fast double @exp2(double [[MUL]])
; CHECK-NEXT:    ret double [[EXP2]]
;
  %call = call fast double @exp2(double %x) nounwind readnone
  %pow = call fast double @llvm.pow.f64(double %call, double %y)
  ret double %pow
}

; TODO: exp10() is not widely enabled by many targets yet.

define float @powf_exp10f(float %x, float %y) {
; CHECK-LABEL: @powf_exp10f(
; CHECK-NEXT:    [[CALL:%.*]] = call fast float @exp10f(float [[X:%.*]]) #1
; CHECK-NEXT:    [[POW:%.*]] = call fast float @llvm.pow.f32(float [[CALL]], float [[Y:%.*]])
; CHECK-NEXT:    ret float [[POW]]
;
  %call = call fast float @exp10f(float %x) nounwind readnone
  %pow = call fast float @llvm.pow.f32(float %call, float %y)
  ret float %pow
}

define double @pow_exp10(double %x, double %y) {
; CHECK-LABEL: @pow_exp10(
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @exp10(double [[X:%.*]]) #1
; CHECK-NEXT:    [[POW:%.*]] = call fast double @llvm.pow.f64(double [[CALL]], double [[Y:%.*]])
; CHECK-NEXT:    ret double [[POW]]
;
  %call = call fast double @exp10(double %x) nounwind readnone
  %pow = call fast double @llvm.pow.f64(double %call, double %y)
  ret double %pow
}

define double @pow_exp_not_fast(double %x, double %y) {
; CHECK-LABEL: @pow_exp_not_fast(
; CHECK-NEXT:    [[CALL:%.*]] = call double @exp(double [[X:%.*]])
; CHECK-NEXT:    [[POW:%.*]] = call fast double @llvm.pow.f64(double [[CALL]], double [[Y:%.*]])
; CHECK-NEXT:    ret double [[POW]]
;
  %call = call double @exp(double %x)
  %pow = call fast double @llvm.pow.f64(double %call, double %y)
  ret double %pow
}

define double @function_pointer(double ()* %fptr, double %p1) {
; CHECK-LABEL: @function_pointer(
; CHECK-NEXT:    [[CALL1:%.*]] = call fast double [[FPTR:%.*]]()
; CHECK-NEXT:    [[POW:%.*]] = call fast double @llvm.pow.f64(double [[CALL1]], double [[P1:%.*]])
; CHECK-NEXT:    ret double [[POW]]
;
  %call1 = call fast double %fptr()
  %pow = call fast double @llvm.pow.f64(double %call1, double %p1)
  ret double %pow
}

declare double @exp(double)
declare float @expf(float)
declare double @exp2(double)
declare float @exp2f(float)
declare double @exp10(double)
declare float @exp10f(float)
declare double @llvm.pow.f64(double, double)
declare float @llvm.pow.f32(float, float)
