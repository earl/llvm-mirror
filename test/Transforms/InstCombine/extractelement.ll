; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -instcombine -S -data-layout="e" | FileCheck %s --check-prefixes=ANY,LE
; RUN: opt < %s -instcombine -S -data-layout="E" | FileCheck %s --check-prefixes=ANY,BE

define i32 @extractelement_out_of_range(<2 x i32> %x) {
; ANY-LABEL: @extractelement_out_of_range(
; ANY-NEXT:    ret i32 undef
;
  %E1 = extractelement <2 x i32> %x, i8 16
  ret i32 %E1
}

define i32 @extractelement_type_out_of_range(<2 x i32> %x) {
; ANY-LABEL: @extractelement_type_out_of_range(
; ANY-NEXT:    [[E1:%.*]] = extractelement <2 x i32> [[X:%.*]], i128 0
; ANY-NEXT:    ret i32 [[E1]]
;
  %E1 = extractelement <2 x i32> %x, i128 0
  ret i32 %E1
}

define i32 @bitcasted_inselt_equal_num_elts(float %f) {
; ANY-LABEL: @bitcasted_inselt_equal_num_elts(
; ANY-NEXT:    [[R:%.*]] = bitcast float [[F:%.*]] to i32
; ANY-NEXT:    ret i32 [[R]]
;
  %vf = insertelement <4 x float> undef, float %f, i32 0
  %vi = bitcast <4 x float> %vf to <4 x i32>
  %r = extractelement <4 x i32> %vi, i32 0
  ret i32 %r
}

define i64 @test2(i64 %in) {
; ANY-LABEL: @test2(
; ANY-NEXT:    ret i64 [[IN:%.*]]
;
  %vec = insertelement <8 x i64> undef, i64 %in, i32 0
  %splat = shufflevector <8 x i64> %vec, <8 x i64> undef, <8 x i32> zeroinitializer
  %add = add <8 x i64> %splat, <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7>
  %r = extractelement <8 x i64> %add, i32 0
  ret i64 %r
}

define i32 @bitcasted_inselt_wide_source_zero_elt(i64 %x) {
; LE-LABEL: @bitcasted_inselt_wide_source_zero_elt(
; LE-NEXT:    [[R:%.*]] = trunc i64 [[X:%.*]] to i32
; LE-NEXT:    ret i32 [[R]]
;
; BE-LABEL: @bitcasted_inselt_wide_source_zero_elt(
; BE-NEXT:    [[TMP1:%.*]] = lshr i64 [[X:%.*]], 32
; BE-NEXT:    [[R:%.*]] = trunc i64 [[TMP1]] to i32
; BE-NEXT:    ret i32 [[R]]
;
  %i = insertelement <2 x i64> zeroinitializer, i64 %x, i32 0
  %b = bitcast <2 x i64> %i to <4 x i32>
  %r = extractelement <4 x i32> %b, i32 0
  ret i32 %r
}

define i16 @bitcasted_inselt_wide_source_modulo_elt(i64 %x) {
; LE-LABEL: @bitcasted_inselt_wide_source_modulo_elt(
; LE-NEXT:    [[R:%.*]] = trunc i64 [[X:%.*]] to i16
; LE-NEXT:    ret i16 [[R]]
;
; BE-LABEL: @bitcasted_inselt_wide_source_modulo_elt(
; BE-NEXT:    [[TMP1:%.*]] = lshr i64 [[X:%.*]], 48
; BE-NEXT:    [[R:%.*]] = trunc i64 [[TMP1]] to i16
; BE-NEXT:    ret i16 [[R]]
;
  %i = insertelement <2 x i64> undef, i64 %x, i32 1
  %b = bitcast <2 x i64> %i to <8 x i16>
  %r = extractelement <8 x i16> %b, i32 4
  ret i16 %r
}

define i32 @bitcasted_inselt_wide_source_not_modulo_elt(i64 %x) {
; LE-LABEL: @bitcasted_inselt_wide_source_not_modulo_elt(
; LE-NEXT:    [[TMP1:%.*]] = lshr i64 [[X:%.*]], 32
; LE-NEXT:    [[R:%.*]] = trunc i64 [[TMP1]] to i32
; LE-NEXT:    ret i32 [[R]]
;
; BE-LABEL: @bitcasted_inselt_wide_source_not_modulo_elt(
; BE-NEXT:    [[R:%.*]] = trunc i64 [[X:%.*]] to i32
; BE-NEXT:    ret i32 [[R]]
;
  %i = insertelement <2 x i64> undef, i64 %x, i32 0
  %b = bitcast <2 x i64> %i to <4 x i32>
  %r = extractelement <4 x i32> %b, i32 1
  ret i32 %r
}

define i8 @bitcasted_inselt_wide_source_not_modulo_elt_not_half(i32 %x) {
; LE-LABEL: @bitcasted_inselt_wide_source_not_modulo_elt_not_half(
; LE-NEXT:    [[TMP1:%.*]] = lshr i32 [[X:%.*]], 16
; LE-NEXT:    [[R:%.*]] = trunc i32 [[TMP1]] to i8
; LE-NEXT:    ret i8 [[R]]
;
; BE-LABEL: @bitcasted_inselt_wide_source_not_modulo_elt_not_half(
; BE-NEXT:    [[TMP1:%.*]] = lshr i32 [[X:%.*]], 8
; BE-NEXT:    [[R:%.*]] = trunc i32 [[TMP1]] to i8
; BE-NEXT:    ret i8 [[R]]
;
  %i = insertelement <2 x i32> undef, i32 %x, i32 0
  %b = bitcast <2 x i32> %i to <8 x i8>
  %r = extractelement <8 x i8> %b, i32 2
  ret i8 %r
}

define i3 @bitcasted_inselt_wide_source_not_modulo_elt_not_half_weird_types(i15 %x) {
; LE-LABEL: @bitcasted_inselt_wide_source_not_modulo_elt_not_half_weird_types(
; LE-NEXT:    [[TMP1:%.*]] = lshr i15 [[X:%.*]], 3
; LE-NEXT:    [[R:%.*]] = trunc i15 [[TMP1]] to i3
; LE-NEXT:    ret i3 [[R]]
;
; BE-LABEL: @bitcasted_inselt_wide_source_not_modulo_elt_not_half_weird_types(
; BE-NEXT:    [[TMP1:%.*]] = lshr i15 [[X:%.*]], 9
; BE-NEXT:    [[R:%.*]] = trunc i15 [[TMP1]] to i3
; BE-NEXT:    ret i3 [[R]]
;
  %i = insertelement <3 x i15> undef, i15 %x, i32 0
  %b = bitcast <3 x i15> %i to <15 x i3>
  %r = extractelement <15 x i3> %b, i32 1
  ret i3 %r
}

; Negative test for the above fold, but we can remove the insert here.

define i8 @bitcasted_inselt_wide_source_wrong_insert(<2 x i32> %v, i32 %x) {
; ANY-LABEL: @bitcasted_inselt_wide_source_wrong_insert(
; ANY-NEXT:    [[B:%.*]] = bitcast <2 x i32> [[V:%.*]] to <8 x i8>
; ANY-NEXT:    [[R:%.*]] = extractelement <8 x i8> [[B]], i32 2
; ANY-NEXT:    ret i8 [[R]]
;
  %i = insertelement <2 x i32> %v, i32 %x, i32 1
  %b = bitcast <2 x i32> %i to <8 x i8>
  %r = extractelement <8 x i8> %b, i32 2
  ret i8 %r
}

; Partial negative test for the above fold, extra uses are not allowed if shift is needed.

declare void @use(<8 x i8>)

define i8 @bitcasted_inselt_wide_source_uses(i32 %x) {
; LE-LABEL: @bitcasted_inselt_wide_source_uses(
; LE-NEXT:    [[I:%.*]] = insertelement <2 x i32> undef, i32 [[X:%.*]], i32 0
; LE-NEXT:    [[B:%.*]] = bitcast <2 x i32> [[I]] to <8 x i8>
; LE-NEXT:    call void @use(<8 x i8> [[B]])
; LE-NEXT:    [[R:%.*]] = extractelement <8 x i8> [[B]], i32 3
; LE-NEXT:    ret i8 [[R]]
;
; BE-LABEL: @bitcasted_inselt_wide_source_uses(
; BE-NEXT:    [[I:%.*]] = insertelement <2 x i32> undef, i32 [[X:%.*]], i32 0
; BE-NEXT:    [[B:%.*]] = bitcast <2 x i32> [[I]] to <8 x i8>
; BE-NEXT:    call void @use(<8 x i8> [[B]])
; BE-NEXT:    [[R:%.*]] = trunc i32 [[X]] to i8
; BE-NEXT:    ret i8 [[R]]
;
  %i = insertelement <2 x i32> undef, i32 %x, i32 0
  %b = bitcast <2 x i32> %i to <8 x i8>
  call void @use(<8 x i8> %b)
  %r = extractelement <8 x i8> %b, i32 3
  ret i8 %r
}

