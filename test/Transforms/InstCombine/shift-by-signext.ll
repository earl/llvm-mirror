; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt %s -instcombine -S | FileCheck %s

; If we have a shift by sign-extended value, we can replace sign-extension
; with zero-extension.

define i32 @t0_shl(i32 %x, i8 %shamt) {
; CHECK-LABEL: @t0_shl(
; CHECK-NEXT:    [[SHAMT_WIDE:%.*]] = sext i8 [[SHAMT:%.*]] to i32
; CHECK-NEXT:    [[R:%.*]] = shl i32 [[X:%.*]], [[SHAMT_WIDE]]
; CHECK-NEXT:    ret i32 [[R]]
;
  %shamt_wide = sext i8 %shamt to i32
  %r = shl i32 %x, %shamt_wide
  ret i32 %r
}
define i32 @t1_lshr(i32 %x, i8 %shamt) {
; CHECK-LABEL: @t1_lshr(
; CHECK-NEXT:    [[SHAMT_WIDE:%.*]] = sext i8 [[SHAMT:%.*]] to i32
; CHECK-NEXT:    [[R:%.*]] = lshr i32 [[X:%.*]], [[SHAMT_WIDE]]
; CHECK-NEXT:    ret i32 [[R]]
;
  %shamt_wide = sext i8 %shamt to i32
  %r = lshr i32 %x, %shamt_wide
  ret i32 %r
}
define i32 @t2_ashr(i32 %x, i8 %shamt) {
; CHECK-LABEL: @t2_ashr(
; CHECK-NEXT:    [[SHAMT_WIDE:%.*]] = sext i8 [[SHAMT:%.*]] to i32
; CHECK-NEXT:    [[R:%.*]] = ashr i32 [[X:%.*]], [[SHAMT_WIDE]]
; CHECK-NEXT:    ret i32 [[R]]
;
  %shamt_wide = sext i8 %shamt to i32
  %r = ashr i32 %x, %shamt_wide
  ret i32 %r
}

define <2 x i32> @t3_vec_shl(<2 x i32> %x, <2 x i8> %shamt) {
; CHECK-LABEL: @t3_vec_shl(
; CHECK-NEXT:    [[SHAMT_WIDE:%.*]] = sext <2 x i8> [[SHAMT:%.*]] to <2 x i32>
; CHECK-NEXT:    [[R:%.*]] = shl <2 x i32> [[X:%.*]], [[SHAMT_WIDE]]
; CHECK-NEXT:    ret <2 x i32> [[R]]
;
  %shamt_wide = sext <2 x i8> %shamt to <2 x i32>
  %r = shl <2 x i32> %x, %shamt_wide
  ret <2 x i32> %r
}
define <2 x i32> @t4_vec_lshr(<2 x i32> %x, <2 x i8> %shamt) {
; CHECK-LABEL: @t4_vec_lshr(
; CHECK-NEXT:    [[SHAMT_WIDE:%.*]] = sext <2 x i8> [[SHAMT:%.*]] to <2 x i32>
; CHECK-NEXT:    [[R:%.*]] = lshr <2 x i32> [[X:%.*]], [[SHAMT_WIDE]]
; CHECK-NEXT:    ret <2 x i32> [[R]]
;
  %shamt_wide = sext <2 x i8> %shamt to <2 x i32>
  %r = lshr <2 x i32> %x, %shamt_wide
  ret <2 x i32> %r
}
define <2 x i32> @t5_vec_ashr(<2 x i32> %x, <2 x i8> %shamt) {
; CHECK-LABEL: @t5_vec_ashr(
; CHECK-NEXT:    [[SHAMT_WIDE:%.*]] = sext <2 x i8> [[SHAMT:%.*]] to <2 x i32>
; CHECK-NEXT:    [[R:%.*]] = ashr <2 x i32> [[X:%.*]], [[SHAMT_WIDE]]
; CHECK-NEXT:    ret <2 x i32> [[R]]
;
  %shamt_wide = sext <2 x i8> %shamt to <2 x i32>
  %r = ashr <2 x i32> %x, %shamt_wide
  ret <2 x i32> %r
}

; This is not valid for funnel shifts
declare i32 @llvm.fshl.i32(i32 %a, i32 %b, i32 %c)
declare i32 @llvm.fshr.i32(i32 %a, i32 %b, i32 %c)
define i32 @n6_fshl(i32 %x, i32 %y, i8 %shamt) {
; CHECK-LABEL: @n6_fshl(
; CHECK-NEXT:    [[SHAMT_WIDE1:%.*]] = zext i8 [[SHAMT:%.*]] to i32
; CHECK-NEXT:    [[R:%.*]] = call i32 @llvm.fshl.i32(i32 [[X:%.*]], i32 [[Y:%.*]], i32 [[SHAMT_WIDE1]])
; CHECK-NEXT:    ret i32 [[R]]
;
  %shamt_wide = sext i8 %shamt to i32
  %r = call i32 @llvm.fshl.i32(i32 %x, i32 %y, i32 %shamt_wide)
  ret i32 %r
}
define i32 @n7_fshr(i32 %x, i32 %y, i8 %shamt) {
; CHECK-LABEL: @n7_fshr(
; CHECK-NEXT:    [[SHAMT_WIDE1:%.*]] = zext i8 [[SHAMT:%.*]] to i32
; CHECK-NEXT:    [[R:%.*]] = call i32 @llvm.fshr.i32(i32 [[X:%.*]], i32 [[Y:%.*]], i32 [[SHAMT_WIDE1]])
; CHECK-NEXT:    ret i32 [[R]]
;
  %shamt_wide = sext i8 %shamt to i32
  %r = call i32 @llvm.fshr.i32(i32 %x, i32 %y, i32 %shamt_wide)
  ret i32 %r
}

declare void @use32(i32)
define i32 @n8_extrause(i32 %x, i8 %shamt) {
; CHECK-LABEL: @n8_extrause(
; CHECK-NEXT:    [[SHAMT_WIDE:%.*]] = sext i8 [[SHAMT:%.*]] to i32
; CHECK-NEXT:    call void @use32(i32 [[SHAMT_WIDE]])
; CHECK-NEXT:    [[R:%.*]] = shl i32 [[X:%.*]], [[SHAMT_WIDE]]
; CHECK-NEXT:    ret i32 [[R]]
;
  %shamt_wide = sext i8 %shamt to i32
  call void @use32(i32 %shamt_wide)
  %r = shl i32 %x, %shamt_wide
  ret i32 %r
}
