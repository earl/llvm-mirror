; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -O2 -S -mcpu=pwr8 < %s | FileCheck %s
target datalayout = "e-m:e-i64:64-n32:64"
target triple = "powerpc64le-unknown-linux-gnu"

@zeroEqualityTest01.buffer1 = private unnamed_addr constant [3 x i32] [i32 1, i32 2, i32 4], align 4
@zeroEqualityTest01.buffer2 = private unnamed_addr constant [3 x i32] [i32 1, i32 2, i32 3], align 4
@zeroEqualityTest02.buffer1 = private unnamed_addr constant [4 x i32] [i32 4, i32 0, i32 0, i32 0], align 4
@zeroEqualityTest02.buffer2 = private unnamed_addr constant [4 x i32] [i32 3, i32 0, i32 0, i32 0], align 4
@zeroEqualityTest03.buffer1 = private unnamed_addr constant [4 x i32] [i32 0, i32 0, i32 0, i32 3], align 4
@zeroEqualityTest03.buffer2 = private unnamed_addr constant [4 x i32] [i32 0, i32 0, i32 0, i32 4], align 4
@zeroEqualityTest04.buffer1 = private unnamed_addr constant [15 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14], align 4
@zeroEqualityTest04.buffer2 = private unnamed_addr constant [15 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 13], align 4

declare signext i32 @memcmp(i8* nocapture, i8* nocapture, i64) local_unnamed_addr #1

; Check 4 bytes - requires 1 load for each param.
define signext i32 @zeroEqualityTest02(i8* %x, i8* %y) {
; CHECK-LABEL: @zeroEqualityTest02(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8* [[X:%.*]] to i32*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8* [[Y:%.*]] to i32*
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32* [[TMP1]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32* [[TMP2]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = zext i1 [[TMP5]] to i32
; CHECK-NEXT:    ret i32 [[TMP6]]
;
  %call = tail call signext i32 @memcmp(i8* %x, i8* %y, i64 4)
  %not.cmp = icmp ne i32 %call, 0
  %. = zext i1 %not.cmp to i32
  ret i32 %.
}

; Check 16 bytes - requires 2 loads for each param (or use vectors?).
define signext i32 @zeroEqualityTest01(i8* %x, i8* %y) {
; CHECK-LABEL: @zeroEqualityTest01(
; CHECK-NEXT:  loadbb:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8* [[X:%.*]] to i64*
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8* [[Y:%.*]] to i64*
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, i64* [[TMP0]], align 8
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64* [[TMP1]], align 8
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[TMP2]], [[TMP3]]
; CHECK-NEXT:    br i1 [[TMP4]], label [[LOADBB1:%.*]], label [[RES_BLOCK:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, i8* [[X]], i64 8
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8* [[TMP5]] to i64*
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8* [[Y]], i64 8
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8* [[TMP7]] to i64*
; CHECK-NEXT:    [[TMP9:%.*]] = load i64, i64* [[TMP6]], align 8
; CHECK-NEXT:    [[TMP10:%.*]] = load i64, i64* [[TMP8]], align 8
; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[TMP9]], [[TMP10]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ 1, [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call signext i32 @memcmp(i8* %x, i8* %y, i64 16)
  %not.tobool = icmp ne i32 %call, 0
  %. = zext i1 %not.tobool to i32
  ret i32 %.
}

; Check 7 bytes - requires 3 loads for each param.
define signext i32 @zeroEqualityTest03(i8* %x, i8* %y) {
; CHECK-LABEL: @zeroEqualityTest03(
; CHECK-NEXT:  loadbb:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8* [[X:%.*]] to i32*
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8* [[Y:%.*]] to i32*
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32* [[TMP1]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i32 [[TMP2]], [[TMP3]]
; CHECK-NEXT:    br i1 [[TMP4]], label [[LOADBB1:%.*]], label [[RES_BLOCK:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, i8* [[X]], i64 4
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8* [[TMP5]] to i16*
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8* [[Y]], i64 4
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8* [[TMP7]] to i16*
; CHECK-NEXT:    [[TMP9:%.*]] = load i16, i16* [[TMP6]], align 2
; CHECK-NEXT:    [[TMP10:%.*]] = load i16, i16* [[TMP8]], align 2
; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i16 [[TMP9]], [[TMP10]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[LOADBB2:%.*]], label [[RES_BLOCK]]
; CHECK:       loadbb2:
; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr i8, i8* [[X]], i64 6
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, i8* [[Y]], i64 6
; CHECK-NEXT:    [[TMP14:%.*]] = load i8, i8* [[TMP12]], align 1
; CHECK-NEXT:    [[TMP15:%.*]] = load i8, i8* [[TMP13]], align 1
; CHECK-NEXT:    [[TMP16:%.*]] = icmp eq i8 [[TMP14]], [[TMP15]]
; CHECK-NEXT:    br i1 [[TMP16]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB2]] ], [ 1, [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call signext i32 @memcmp(i8* %x, i8* %y, i64 7)
  %not.lnot = icmp ne i32 %call, 0
  %cond = zext i1 %not.lnot to i32
  ret i32 %cond
}

; Validate with > 0
define signext i32 @zeroEqualityTest04() {
; CHECK-LABEL: @zeroEqualityTest04(
; CHECK-NEXT:  loadbb:
; CHECK-NEXT:    ret i32 0
;
  %call = tail call signext i32 @memcmp(i8* bitcast ([4 x i32]* @zeroEqualityTest02.buffer1 to i8*), i8* bitcast ([4 x i32]* @zeroEqualityTest02.buffer2 to i8*), i64 16)
  %not.cmp = icmp slt i32 %call, 1
  %. = zext i1 %not.cmp to i32
  ret i32 %.
}

; Validate with < 0
define signext i32 @zeroEqualityTest05() {
; CHECK-LABEL: @zeroEqualityTest05(
; CHECK-NEXT:  loadbb:
; CHECK-NEXT:    ret i32 0
;
  %call = tail call signext i32 @memcmp(i8* bitcast ([4 x i32]* @zeroEqualityTest03.buffer1 to i8*), i8* bitcast ([4 x i32]* @zeroEqualityTest03.buffer2 to i8*), i64 16)
  %call.lobit = lshr i32 %call, 31
  %call.lobit.not = xor i32 %call.lobit, 1
  ret i32 %call.lobit.not
}

; Validate with memcmp()?:
define signext i32 @equalityFoldTwoConstants() {
; CHECK-LABEL: @equalityFoldTwoConstants(
; CHECK-NEXT:  loadbb:
; CHECK-NEXT:    ret i32 1
;
  %call = tail call signext i32 @memcmp(i8* bitcast ([15 x i32]* @zeroEqualityTest04.buffer1 to i8*), i8* bitcast ([15 x i32]* @zeroEqualityTest04.buffer2 to i8*), i64 16)
  %not.tobool = icmp eq i32 %call, 0
  %cond = zext i1 %not.tobool to i32
  ret i32 %cond
}

define signext i32 @equalityFoldOneConstant(i8* %X) {
; CHECK-LABEL: @equalityFoldOneConstant(
; CHECK-NEXT:  loadbb:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8* [[X:%.*]] to i64*
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, i64* [[TMP0]], align 8
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i64 [[TMP1]], 4294967296
; CHECK-NEXT:    br i1 [[TMP2]], label [[LOADBB1:%.*]], label [[RES_BLOCK:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, i8* [[X]], i64 8
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8* [[TMP3]] to i64*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64* [[TMP4]], align 8
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i64 [[TMP5]], 12884901890
; CHECK-NEXT:    br i1 [[TMP6]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 1, [[LOADBB1]] ], [ 0, [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call signext i32 @memcmp(i8* bitcast ([15 x i32]* @zeroEqualityTest04.buffer1 to i8*), i8* %X, i64 16)
  %not.tobool = icmp eq i32 %call, 0
  %cond = zext i1 %not.tobool to i32
  ret i32 %cond
}

define i1 @length2_eq_nobuiltin_attr(i8* %X, i8* %Y) {
; CHECK-LABEL: @length2_eq_nobuiltin_attr(
; CHECK-NEXT:    [[M:%.*]] = tail call signext i32 @memcmp(i8* [[X:%.*]], i8* [[Y:%.*]], i64 2) #2
; CHECK-NEXT:    [[C:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    ret i1 [[C]]
;
  %m = tail call signext i32 @memcmp(i8* %X, i8* %Y, i64 2) nobuiltin
  %c = icmp eq i32 %m, 0
  ret i1 %c
}

