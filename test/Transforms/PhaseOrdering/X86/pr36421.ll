; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -O2 -S | FileCheck %s

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
target triple = "x86_64-unknown-unknown"

@.str = private unnamed_addr constant [7 x i8] c"abcdef\00", align 1
@.str.1 = private unnamed_addr constant [7 x i8] c"ABCDEF\00", align 1

define i32 @test(i8* nocapture readonly %string, i32 %len) local_unnamed_addr #0 {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[LEN:%.*]], 6
; CHECK-NEXT:    br i1 [[COND]], label [[SW_BB:%.*]], label [[RETURN:%.*]]
; CHECK:       sw.bb:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8* [[STRING:%.*]] to i32*
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, i8* [[STRING]], i64 4
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8* [[TMP2]] to i16*
; CHECK-NEXT:    [[TMP4:%.*]] = load i16, i16* [[TMP3]], align 2
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[TMP1]], 1684234849
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i16 [[TMP4]], 26213
; CHECK-NEXT:    [[CMP:%.*]] = and i1 [[TMP6]], [[TMP5]]
; CHECK-NEXT:    br i1 [[CMP]], label [[RETURN]], label [[IF_END:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[TMP7:%.*]] = xor i32 [[TMP1]], 1145258561
; CHECK-NEXT:    [[TMP8:%.*]] = xor i16 [[TMP4]], 17989
; CHECK-NEXT:    [[TMP9:%.*]] = zext i16 [[TMP8]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = or i32 [[TMP7]], [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i32 [[TMP10]], 0
; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[TMP11]], i32 64, i32 0
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 61, [[SW_BB]] ], [ [[DOT]], [[IF_END]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %cond = icmp eq i32 %len, 6
  br i1 %cond, label %sw.bb, label %return

sw.bb:                                            ; preds = %entry
  %call = tail call i32 @memcmp(i8* %string, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i64 6)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %sw.bb
  %call1 = tail call i32 @memcmp(i8* %string, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i64 0, i64 0), i64 6)
  %cmp2 = icmp eq i32 %call1, 0
  %. = select i1 %cmp2, i32 64, i32 0
  br label %return

return:                                           ; preds = %entry, %if.end8, %if.end4, %if.end, %sw.bb
  %retval.0 = phi i32 [ 61, %sw.bb ], [ %., %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) local_unnamed_addr #1

attributes #0 = { nounwind readonly ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!"clang version 7.0.0 (trunk 325350)"}
