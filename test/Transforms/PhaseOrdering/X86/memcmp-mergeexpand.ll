; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -mergeicmps -expandmemcmp -mtriple=i386-unknown-linux < %s | FileCheck %s --check-prefix=X86
; RUN: opt -S -mergeicmps -expandmemcmp -mtriple=x86_64-unknown-linux < %s | FileCheck %s --check-prefix=X64

; This tests interaction between MergeICmp and ExpandMemCmp.

%"struct.std::pair" = type { i32, i32 }

define zeroext i1 @opeq1(
; X86-LABEL: @opeq1(
; X86-NEXT:  "entry+land.rhs.i":
; X86-NEXT:    [[TMP0:%.*]] = getelementptr inbounds %"struct.std::pair", %"struct.std::pair"* [[A:%.*]], i64 0, i32 0
; X86-NEXT:    [[TMP1:%.*]] = getelementptr inbounds %"struct.std::pair", %"struct.std::pair"* [[B:%.*]], i64 0, i32 0
; X86-NEXT:    [[CSTR:%.*]] = bitcast i32* [[TMP0]] to i8*
; X86-NEXT:    [[CSTR1:%.*]] = bitcast i32* [[TMP1]] to i8*
; X86-NEXT:    [[TMP2:%.*]] = bitcast i8* [[CSTR]] to i32*
; X86-NEXT:    [[TMP3:%.*]] = bitcast i8* [[CSTR1]] to i32*
; X86-NEXT:    [[TMP4:%.*]] = load i32, i32* [[TMP2]]
; X86-NEXT:    [[TMP5:%.*]] = load i32, i32* [[TMP3]]
; X86-NEXT:    [[TMP6:%.*]] = xor i32 [[TMP4]], [[TMP5]]
; X86-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8* [[CSTR]], i8 4
; X86-NEXT:    [[TMP8:%.*]] = bitcast i8* [[TMP7]] to i32*
; X86-NEXT:    [[TMP9:%.*]] = getelementptr i8, i8* [[CSTR1]], i8 4
; X86-NEXT:    [[TMP10:%.*]] = bitcast i8* [[TMP9]] to i32*
; X86-NEXT:    [[TMP11:%.*]] = load i32, i32* [[TMP8]]
; X86-NEXT:    [[TMP12:%.*]] = load i32, i32* [[TMP10]]
; X86-NEXT:    [[TMP13:%.*]] = xor i32 [[TMP11]], [[TMP12]]
; X86-NEXT:    [[TMP14:%.*]] = or i32 [[TMP6]], [[TMP13]]
; X86-NEXT:    [[TMP15:%.*]] = icmp ne i32 [[TMP14]], 0
; X86-NEXT:    [[TMP16:%.*]] = zext i1 [[TMP15]] to i32
; X86-NEXT:    [[TMP17:%.*]] = icmp eq i32 [[TMP16]], 0
; X86-NEXT:    br label [[OPEQ1_EXIT:%.*]]
; X86:       opeq1.exit:
; X86-NEXT:    ret i1 [[TMP17]]
;
; X64-LABEL: @opeq1(
; X64-NEXT:  "entry+land.rhs.i":
; X64-NEXT:    [[TMP0:%.*]] = getelementptr inbounds %"struct.std::pair", %"struct.std::pair"* [[A:%.*]], i64 0, i32 0
; X64-NEXT:    [[TMP1:%.*]] = getelementptr inbounds %"struct.std::pair", %"struct.std::pair"* [[B:%.*]], i64 0, i32 0
; X64-NEXT:    [[CSTR:%.*]] = bitcast i32* [[TMP0]] to i8*
; X64-NEXT:    [[CSTR1:%.*]] = bitcast i32* [[TMP1]] to i8*
; X64-NEXT:    [[TMP2:%.*]] = bitcast i8* [[CSTR]] to i64*
; X64-NEXT:    [[TMP3:%.*]] = bitcast i8* [[CSTR1]] to i64*
; X64-NEXT:    [[TMP4:%.*]] = load i64, i64* [[TMP2]]
; X64-NEXT:    [[TMP5:%.*]] = load i64, i64* [[TMP3]]
; X64-NEXT:    [[TMP6:%.*]] = icmp ne i64 [[TMP4]], [[TMP5]]
; X64-NEXT:    [[TMP7:%.*]] = zext i1 [[TMP6]] to i32
; X64-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[TMP7]], 0
; X64-NEXT:    br label [[OPEQ1_EXIT:%.*]]
; X64:       opeq1.exit:
; X64-NEXT:    ret i1 [[TMP8]]
;
  %"struct.std::pair"* nocapture readonly dereferenceable(8) %a,
  %"struct.std::pair"* nocapture readonly dereferenceable(8) %b) local_unnamed_addr #0 {
entry:
  %first.i = getelementptr inbounds %"struct.std::pair", %"struct.std::pair"* %a, i64 0, i32 0
  %0 = load i32, i32* %first.i, align 4
  %first1.i = getelementptr inbounds %"struct.std::pair", %"struct.std::pair"* %b, i64 0, i32 0
  %1 = load i32, i32* %first1.i, align 4
  %cmp.i = icmp eq i32 %0, %1
  br i1 %cmp.i, label %land.rhs.i, label %opeq1.exit

land.rhs.i:
  %second.i = getelementptr inbounds %"struct.std::pair", %"struct.std::pair"* %a, i64 0, i32 1
  %2 = load i32, i32* %second.i, align 4
  %second2.i = getelementptr inbounds %"struct.std::pair", %"struct.std::pair"* %b, i64 0, i32 1
  %3 = load i32, i32* %second2.i, align 4
  %cmp3.i = icmp eq i32 %2, %3
  br label %opeq1.exit

opeq1.exit:
  %4 = phi i1 [ false, %entry ], [ %cmp3.i, %land.rhs.i ]
  ret i1 %4
}


