//===- AMDGPUGenRegisterBankInfo.def -----------------------------*- C++ -*-==//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
/// \file
/// This file defines all the static objects used by AMDGPURegisterBankInfo.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

namespace llvm {
namespace AMDGPU {

enum PartialMappingIdx {
  None = - 1,
  PM_SGPR32 = 0,
  PM_SGPR64 = 1,
  PM_VGPR32 = 2,
  PM_VGPR64 = 3,
  PM_SGPR1  = 4,
  PM_VGPR1  = 5,
};

const RegisterBankInfo::PartialMapping PartMappings[] {
  // StartIdx, Length, RegBank
  {0, 32, SGPRRegBank},
  {0, 64, SGPRRegBank},
  {0, 32, VGPRRegBank},
  {0, 64, VGPRRegBank},
  {0, 1,  SCCRegBank},
  {0, 1,  SGPRRegBank}
};

const RegisterBankInfo::ValueMapping ValMappings[] {
  // SGPR 32-bit
  {&PartMappings[0], 1},
  // SGPR 64-bit
  {&PartMappings[1], 1},
  // VGPR 32-bit
  {&PartMappings[2], 1},
  // VGPR 64-bit
  {&PartMappings[3], 1},
  {&PartMappings[4], 1},
  {&PartMappings[5], 1}
};

enum ValueMappingIdx {
  SGPRStartIdx = 0,
  VGPRStartIdx = 2
};

const RegisterBankInfo::ValueMapping *getValueMapping(unsigned BankID,
                                                      unsigned Size) {
  unsigned Idx;
  if (Size == 1) {
    Idx = BankID == AMDGPU::SCCRegBankID ? PM_SGPR1 : PM_VGPR1;
  } else {
    assert(Size % 32 == 0);
    Idx = BankID == AMDGPU::SGPRRegBankID ? SGPRStartIdx : VGPRStartIdx;
    Idx += (Size / 32) - 1;
  }
  return &ValMappings[Idx];
}

} // End AMDGPU namespace.
} // End llvm namespace.
